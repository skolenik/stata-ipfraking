\inserttype[st0001]{article}
\author{S. Kolenikov}{%
  Stanislav Kolenikov\\Abt SRBI\\kolenikovs@srbi.com
}
\title[Raking survey data]{Updates to the \cmd{ipfraking} ecosystem}
\maketitle

\begin{abstract}
\citet{kolenikov:2014 } introduced package \stcmd{ipfraking} 
for weight calibration procedures known as iterative proportional fitting,
or raking, of complex survey weights.
This article briefly describes the original package,
and adds updates to the core program, as well as a host of 
additional programs that are used to support the process of creating
survey weights in the authors' production code.

\keywords{\inserttag, survey, calibration, weights, raking}
\end{abstract}

\section{Introduction and background}

Large scale social, behavioral and health data are often collected
via complex survey designs that may involve some or all of stratification,
multiple stages of selection and unequal probabilities of selection
\citep{korn:graubard:1995,korn:graubard:1999}.
In an ideal setting, varying probabilities of selection are
accounted for by using the Horvitz-Thompson estimator of the totals
\citep{horvitz:thompson:1952,thompson:1997}, and the remaining
sampling fluctuations can be further ironed out by
post-stratification \citep{holt:smith:1979}.
However, on top of the planned differences in probabilities of obtaining
a response from a sampled unit, non-response is a practical problem
that has been growing more acute over the recent years
\citep{groves:dillman:eltinge:little:2001,pew:2012}.
The analysis weights that are provided along with the public use
microdata by data collecting agencies are designed to account
for unequal probabilities of selection, non-response, and other factors
affecting imbalance between the population and the sample, thus making
the analyses conducted on such microdata generalizable to the target population.

Earlier, I introduced \citep{kolenikov:2014} a Stata package
called \stcmd{ipfraking} that implements 
calibration of survey weights to known control totals to ensure
that the resulting weighted data are representative of the population
of interest. The process of calibration is aimed at aligning the sample totals
of the key variables with those known for the population as a whole.

For a given finite population $\mathcal U$ of units indexed $i=1,\ldots,N$,
the interests of survey statisticians often lie in estimating the
population total of a variable $Y$
\begin{equation}
   T[Y] = \sum_{i \in \mathcal{U}} Y_i
   \label{eq:total:pop}
\end{equation}
A sample $\mathcal S$ of $n$ units indexed by $j=1,\ldots,n$
is taken from $\mathcal U$. If the probability to select the
$i$-th unit is known to be $\pi_i$, then
the {\it probability weights}, or {\it design weights}, are given by
the inverse probability of selection:
\begin{equation}
   w_{1i} = \pi_i^{-1}
   \label{eq:prob:weight}
\end{equation}
With these weights, an unbiased
(design-based, non-parametric) estimator
of the total (\ref{eq:total:pop}) is \citep{horvitz:thompson:1952}
\begin{equation}
   t_{1}[y] = \sum_{j \in \mathcal{S}} \frac{y_j}{\pi_j}
   \equiv \sum_{j \in \mathcal{S}} w_{1j} y_j
   \label{eq:total:sample},
\end{equation}
The subindex $1$ indicates that the weights $w_{1i}$ were
used in obtaining this estimator. Probability weights protect
the end user from potentially informative sampling designs, in which
the probabilities of selection are correlated with outcomes, and
the design-based methods generally ensure that inference can be generalized
to the finite population even when the statistical models used
by analysts and researchers are not specified correctly
\citep{pfeff:1993,binder:roberts:2003}.

Often, survey statisticians have auxiliary information on the units
in the frame, and such information can be included it at the sampling stage
to create more efficient designs. Unequal probabilities of selection
are then controlled with probability weights, implemented
as \stcmd{[pw=}{\it exp}\stcmd{]} in Stata (and can be permanently
affixed to the data set with \stcmd{svyset} command).

In many situations, however, usable information is not available beforehand,
and may only appear in the collected data. The census totals of the age and gender
distribution of the population may exist, but age and gender of
the sampled units is unknown until the survey measurement is taken on them.
It is still possible to capitalize on this additional data by
adjusting the weights in such a way that the reweighted data
conforms to these known figures. The procedures to perform these
reweighting steps are generally known as {\it weight calibration}
\citep{deville:sarndal:1992,deville:sarndal:sautory:1993,%
kott:2006,kott:2009,sarndal:2007}.

Suppose there are several (categorical) variables, referred to
as {\it control variables}, that are available for both
the population and the sample
(age groups, race, gender, educational attainment, etc.).
Weight calibration aims at adjusting the margins, or low level interactions,
via an iterative optimization aimed at satisfying
the {\it control totals} for the control variables $\mathbf{x}=(x_1, \ldots, x_p)$:
\begin{equation}
    \sum_{j \in \mathcal{S}} w_{3j} \mathbf{x}_j
    = T [ \mathbf{X}_j  ]
    \label{eq:control:totals}
\end{equation}
where the right hand side is assumed to be known from a census or
a higher quality survey.
\citet{deville:sarndal:1992} framed the problem of finding a suitable
set of weights as that of constrained optimization with the control
equations (\ref{eq:control:totals}) serving as constraints,
and optimization targeted at making the discrepancy between
the design weights $w_{1j}$ and calibrated weights
$w_{3j}$ as close as possible, in a suitable sense. 

In package \stcmd{ipfraking} \citep{kolenikov:2014}, I implemented
a popular calibration algorithm, known as \textit{iterated proportional fitting},
or as \textit{raking}, which consists of iterative updating (post-stratification) of
each of the margins. (For an in-depth discussion of distinctions between
raking and post-stratification, see \citet{kolenikov:2016}.) 
Since 2014, the continuing code development resulted 
in additional features that this update documents.

\section{Package description}

Below, I provide full syntax, and list the new features in a dedicated section.

\subsection{Syntax of \stcmd{ipfraking}}
\label{subsec:syntax}

\begin{stsyntax}
ipfraking
\optif\
\optin\
\optweight\
,
\underbar{ctot}al({\it matname} [{\it matname \ldots}])
\optional{
\underbar{gen}erate(\newvarname)
replace
double
\underbar{iter}ate(\num)
\underbar{tol}erance(\num)
\underbar{ctrltol}erance(\num)
trace
\underbar{nodiv}ergence
trimhiabs(\num)
trimhirel(\num)
trimloabs(\num)
trimlorel(\num)
trimfrequency(once|sometimes|often)
double
meta
nograph
}
\end{stsyntax}

\hangpara
Note that the weight statement \stcmd{[pw=\varname]} is required, and must contain the initial weights.

\subsection{Options}

\subsubsection{Required options}

\hangpara
\stcmd{\underbar{ctot}al(}{\it matname} \LB{\it matname \ldots}\RB\stcmd{)}
supplies the names of the matrices that contain the control
totals, as well as meta-data about the variables to be used
in calibration.

\begin{sttech}
The row and column names of the control total matrices
(see \pref{matrix rownames}) should be formatted as follows.
\begin{itemize}
    \item \stcmd{rownames}: the name of the control variable
    \item \stcmd{colnames}: the values the control variables takes
    \item \stcmd{coleq}: the name of the variable for which total is computed;
          typically it is identically equal to 1.
\end{itemize}
See examples in Section \ref{sec:examples}.
\end{sttech}

\hangpara
\stcmd{\underbar{gen}erate(\newvarname)}
contains the name of the new variable to contain the raked weights.

\hangpara
\stcmd{replace} indicates that the weight variable supplied in the
\stcmd{[pw=\varname]} expression should be overwritten with the new weights.

One and only one of \stcmd{generate()} or \stcmd{replace} must be specified.

\subsubsection{Options to control convergence}

\begin{sttech}
Convergence in \stcmd{ipfraking} is defined in terms of the maximum relative
change in weights:
\begin{equation}
    D_k = \max_{j \in \mathcal{S}} \frac{|w_j^{k,p}-w_j^{k-1,p}|}{w_j^{k-1,p}}
    \label{eq:conv:ratio:weights}
\end{equation}
When $D_k$ is small, $D_k < \delta_D$, it means that the weights stop
changing between iterations, i.e., the algorithm came to its steady state.
On the other hand, if $D_k > D_{k-1}$, it means that the algorithm
may start diverging, at which point it might be reasonable to terminate it.
See step \ref{step:check:weight:conv} of Algorithm 2 in Section \ref{subsec:trimming}.

Once the algorithm terminates, it also checks whether the control totals
are satisfied. Specifically, for each of the control total matrices
$M_1, \ldots, M_p$, the relative difference vs.\ the corresponding weighted
sample totals $\hat M_1, \ldots, \hat M_p$ is computed:
\begin{equation}
    m_c = {\rm mreldif}( \hat M_c, M_c )
    \label{eq:conv:mreldif}
\end{equation}
where the maximum relative difference of two matrices
$$
{\rm mreldif}(A,B) = \max_{ij} \frac{|a_{ij}-b_{ij}|}{1+|b_{ij}|}
$$
as defined in \dref{functions}. A control relation is satisfied
if $m_c < \delta_T$; otherwise, a warning is issued.
See step \ref{step:check:ctotal:conv} of Algorithm 2 in Section \ref{subsec:trimming}.

Iterations continue until either $k = K$, a specified number of iterations;
$D_k < \delta_D$; or $D_k > D_{k-1}$.
\end{sttech}

\hangpara
\stcmd{\underbar{tol}erance(\num)} defines the $D_k$-convergence
criterion, i.e., $\delta_D$. The default is $\delta_D = 10^{-6}$.

\hangpara
\stcmd{\underbar{iter}ate(\num)} specifies the maximum number
of iterations $K$. The default is $K=2000$.

\hangpara
\stcmd{\underbar{nodiv}ergence} overrides the check
that $D_k > D_{k-1}$, i.e., ignores this termination condition.

\hangpara
\stcmd{\underbar{ctrltol}erance(\num)} defines the criterion $\delta_T$ to
assess the accuracy of the control totals. It does not impact
iterations or convergence criteria; it only serves as the final quality control check
after the algorithm terminates as defined above. The default value is $\delta_T=10^{-6}$.

\hangpara
\stcmd{trace} requests a trace plot to be added. See
Section \ref{subsec:example:trace}.

\subsubsection{Trimming options}
\label{subsubsec:trimming}

\hangpara
\stcmd{trimhiabs(\num)} specifies the upper bound $U$ on the greatest
    value of the raked weights.  The weights that
    exceed this value will be trimmed down, so that
    $w_{3j} \le U$ for every $j\in\mathcal{S}$.

\hangpara
\stcmd{trimhirel(\num)} specifies the upper bound $u$ on the adjustment
    factor over the baseline weight. The weights
    that exceed the baseline times this value will be trimmed down,
    so that $w_{3j} \le u w_{1j}$ for every $j\in\mathcal{S}$.

\hangpara
\stcmd{trimloabs(\num)} specifies the lower bound $L$ on the smallest value
    of the raked weights.  The weights that are smaller than this value will
    be increased, so that $w_{3j} \ge L$ for every $j\in\mathcal{S}$.

\hangpara
\stcmd{trimlorel(\num)} specifies the lower bound $l$ on the adjustment factor
    over the baseline weight.  The weights that are smaller than the baseline
    times this value will be increased, so that
    $w_{3j} \ge l w_{1j}$ for every $j\in\mathcal{S}$.

\hangpara
\stcmd{trimfreqency({\it keyword})} specifies when the trimming operations
    are to be performed. The following keywords are recognized:

\morehang \stcmd{often} means that trimming will be performed
    after each marginal adjustment, i.e., within each iteration of the inner
    cycle inside Step \ref{step:trimfreq:often} of Algorithm 2.

\morehang \stcmd{sometimes} means that trimming will be performed
    after a full set of variables has been used for post-stratification, i.e.,
    at the end of each outer cycle iteration at step \ref{step:trimfreq:sometimes} of
    Algorithm 2. This is the default behavior if any of the numeric trimming
    options above are specified.

\morehang \stcmd{once}
    means that trimming will be performed after the outer loop converges
    at step \ref{step:trimfreq:once} of Algorithm 2.

The numeric trimming options \stcmd{trimhiabs(\num)}, \stcmd{trimhirel(\num)},
\stcmd{trimloabs(\num)}, \stcmd{trimlorel(\num)} can be specified in any combination,
or entirely omitted to produce untrimmed weights. By default, there is no trimming.
See Section \ref{subsec:example:trimming} for examples.

\subsubsection{Miscellaneous options}

\hangpara
\stcmd{double} specifies that the new variable named in \stcmd{generate()}
option should be generated as double type. See \dref{data types}.

\hangpara
\stcmd{meta} puts the name(s) of the control vectors and the achieved control
    accuracies $m_c$ as characteristics stored with the variable specified in
    \stcmd{generate()} option. See Section \ref{subsec:example:meta}.

\hangpara
\stcmd{nograph} omits the histogram of the calibrated weights, which can be
used to speed up \stcmd{ipfraking} once the diagnostics on the weights
are completed (e.g., in replicate weight production).

\subsection{New features}

Since the first publication, the following features and options were added.

Option \stcmd{meta} saves more information in characteristics of the calibrated
weight variables.

\subsection{Utility programs}

The original package \stcmd{ipfraking} provided two additional utility programs,
\stcmd{mat2do} and \stcmd{xls2row}. An additional utility program was added
to compute the design effects and margins of error, common tasks associated
with describing survey weights. Specifically, the Transparency Initiative
of the American Association for Public Opinion Research 
\citep{aapor:2014:ti:terms}
requires that 

\begin{cite}
For probability samples, the estimates of sampling error will be reported, and the discussion will state whether or not the reported margins of sampling error or statistical analyses have been adjusted for the design effect due to weighting, clustering, or other factors.
\end{cite}

\begin{stsyntax}
whatsdeff 
{\it weight\_variable}
\optif\
\optin\
,
\optional{
by(\varlist)
}
\end{stsyntax}

The utility program \stcmd{whatsdeff} calculates the apparent design effect due to unequal weighting,
${\rm DEFF_{UWE}}=1 + {CV}^2_w = $ \stcmd{1 + r(Var)/(r(mean))^2} from \stcmd{summarize} {\it weight\_variable}.
Additionally, it reports the effective sample size, $n/{\rm DEFF_{UWE}}$, and also returns
the margins of error for the sample proportions that estimate the population proportions of 
10\% and 50\%.

\begin{stlog}
\input{ipfr.whastdeff.log.tex}\nullskip
\end{stlog}



\section{Examples}
\label{sec:examples}

\subsection{Basic syntax and input requirements}
\label{subsec:basic}

In this very simple example, I shall demonstrate the basic mechanics of
\stcmd{ipfraking}, its input requirements and output.
These examples are intended to only demonstrate the syntax
and the output of \stcmd{ipfraking}, and may or may not provide
substantively meaningful results.


\begin{stexample}[Example 1]

We shall work with the standard example of \stcmd{svy} data,
an excerpt from the NHANES II data set available from Stata Corp.\ website.
We shall introduce some small changes to the data so that
\stcmd{ipfraking} will have some work to do.

\begin{stlog}
\input{ipfr.example1.prep.log.tex}\nullskip
\end{stlog}

Let us now look at the matrices that will serve as an input to the
raking procedure.

\begin{stlog}
\input{ipfr.example1.list.log.tex}\nullskip
\end{stlog}

These input matrices are organized as follows. Input matrices always
have a single row, just as estimation results \stcmd{e(b)} do. The column
names follow the naming conventions of \stcmd{e(b)}, namely,
the name of the variable for which the total is being computed
(here, \stcmd{\_one}) and the numeric categories of the variable that
was used in the \stcmd{over} option (here, \stcmd{sex}, with values 1 for males
and 2 for females; and \stcmd{race}, with values 1 for whites, 2 for blacks,
and 3 for other). These values must be in an increasing order.
Since that variable is not stored in the e(b) per se,
it needs to be added to this matrix, which is done in the form of the row name.
The entries of the matrix are the totals that the weights in the categories
of the control variables need to sum up to. In this example, they are scaled
to be the population totals. Alternatively, these can be made to sum up to the
sample size, as is done sometimes in public opinion research, or to 1, which
is what \stcmd{proportion} estimation command would produce.

The input requirements in terms of control totals are thus made as simple as possible.
If a higher quality survey is available, all the survey statistician needs to do
is to obtain the totals for the categories of the control variables
using \stcmd{svy: total $\cdots$, over( $\cdots$, nolabel ) }
and save the name of that variable along with the matrix.
Note that the \stcmd{total}
is computed with \stcmd{over( \ldots, nolabel)} suboption to suppress
the otherwise informative labeling of the categories;
\stcmd{ipfraking} expects the numeric values of the categories
as column names (see \pref{matrix rownames}).
The name of the matrix itself is immaterial, but it is
a good programming practice
to have informative names \citep{mcconnell:2004}. Thus the names
of the matrices in the examples generally follow the convention
{\it data{\_}source}{\_}{\it variable}.

We are now ready to run \stcmd{ipfraking} and see what it produces.

\begin{stlog}
\input{ipfr.example1.run.log.tex}\nullskip
\end{stlog}

In this simple case with just two control variables
and the control totals that are not very different from the
existing sample totals, the procedure converged very quickly
in three iterations. A diagnostic message was produced upfront
by \stcmd{ipfraking} informing about apparent differences in
total population counts as obtained from the different
control total matrices. As a result, the control totals
for the variable that was adjusted first (\stcmd{sex})
could not match the required control totals even after the
weights converged in the sense of differing little between
iterations. Both of these warnings are only produced when
problems are encountered.

The summary table is always produced, and shows some relevant
characteristics of the original weights $w_{1j}$, the raked weights
$w_{3j}$, and the raking ratios $w_{3j}/w_{1j}$. As expected,
the coefficient of variation went up from 0.645 to 0.672.

The graphic output produced by \stcmd{ipfraking} is shown on
Figure \ref{fig:example1}. Generally, we would want to inspect these
graphs to see if there any unexpected patterns, such as highly outlying values,
gaps in the distribution (here, there are only six distinct values of the
adjustment factor corresponding to the $2\times3$ combinations of the control
variables) or concentration near the limits of the
weight range (as is typical for trimmed weights, see below in section
\ref{subsec:example:trimming}). Also, these graphs
may inform later trimming decisions: the trimming limits can be
chosen to conform to the breaks in the distributions of
the untrimmed raked weights.

\begin{figure}[h!]
\begin{center}
\epsfig{file=ipfraking_example1}
\end{center}
\caption{Histograms of the raked weights and calibration ratios, Example 1.}
\label{fig:example1}
\end{figure}

\end{stexample}

\subsection{Preparing control matrices from scratch}
\label{subsec:acs}

In many situations, the control totals will be obtained
from outside of Stata, and need to be prepared to work
with \stcmd{ipfraking}.

\begin{stexample}[Example 2]

Suppose I wanted to calibrate
the NHANES II data set to the latest control totals available
from the US Census Bureau website. Using the tables
S0101 from the 2011 American Community Survey 1-year estimates
and NST-EST2011 from the US Census Bureau population projections,
the latest available at the time of writing this paper,
the figures displayed in Table \ref{tab:example2} can be obtained.

\begin{table}
\caption{Control totals for the 2011 US population.\label{tab:example2}}

\centering

\begin{tabular}{p{5cm}l}
    Group & Population \\
    \hline
    \multicolumn{2}{c}{~~ACS 2011 1-year estimates, Table S0101~~} \\
    Male, total & 153,267,860 \\
    Ages 20--39 & 27.4\% \\
    Ages 40--59 & 27.5\% \\
    Ages 60+    & 17.3\% \\
    Female, total & 158,324,057 \\
    Ages 20--39 & 26.0\% \\
    Ages 40--59 & 27.6\% \\
    Ages 60+    & 20.7\% \\
    \multicolumn{2}{c}{~~US Census Bureau 2011 projections, Table NST-EST2011-01~~} \\
    Northeast & 55,521,598 \\
    Midwest   & 67,158,835 \\
    South     & 116,046,736 \\
    West      & 72,864,748 \\
    \multicolumn{2}{c}{~~US Census Bureau 2011 projections, Table NC-EST2011-03~~} \\
    White     & 243,470,497 \\
    Black     & 40,750,746 \\
    Other     & 27,370,674 \\
    \hline
    Total     & 311,591,917
\end{tabular}
\end{table}

Thus, we have information in the two-way age by sex table, as well
as two additional margins. We shall need an additional sex-by-age group variable,
and we shall try to make its values somewhat informative
(e.g., the value \stcmd{12} of the variable \stcmd{sex\_age} means
the first group of sex and the second group of age):

\begin{stlog}
\input{ipfr.example2.prep.log.tex}\nullskip
\end{stlog}

With that, the matrices will have to be defined explicitly,
and their labels need to be hand-coded, too (see \pref{matrix rownames}).
Note that the US Census Bureau 2011
projections relate to the total population, while the target population
of the study is the population age 20+. Assuming that the age structure
is the same across regions and races, the control totals for region and race
need to be rescaled to the adult population to avoid the warning messages.
(More accurate figures can be obtained from ACS microdata which can be downloaded
from the U.S.\ Census Bureau website.)

\begin{stlog}
\input{ipfr.example2.mat.log.tex}\nullskip
\end{stlog}

Let us check the matrix entries and labels once again before
producing the weights.
Note that the values of the control variable categories are given in an increasing order.

\begin{stlog}
\input{ipfr.example2.list.log.tex}\nullskip
\end{stlog}

As the labels appear to be in place, let us run \stcmd{ipfraking}:

\begin{stlog}
\input{ipfr.example2.run.log.tex}\nullskip
\end{stlog}

The diagnostic plots for these weights are given in Figure \ref{fig:example2}.
They do appear to have some outlying cases (which are not very clearly seen
on these plots as they are single count observations with outlying weights),
and we shall address them in the next section with trimming.

\begin{figure}[h!]
\begin{center}
\epsfig{file=ipfraking_example2}
\end{center}
\caption{Histograms of the raked weights and calibration ratios, Example 2.}
\label{fig:example2}
\end{figure}

\end{stexample}

\subsection{Trimming options}
\label{subsec:example:trimming}


As discussed in Section \ref{subsec:trimming} above, if variability of the weights
becomes excessive, the weights can be trimmed by restricting the extremes.
Using \stcmd{ipfraking} options, upper and/or lower limits can be defined
for either the absolute values of the weights or the relative changes from
the base weights. The frequency of the trimming operations can also be controlled.
Trimming can be applied once to the final data (\stcmd{trimfreq(once)})
at step \ref{step:trimfreq:once} of Algorithm 2.
Alternatively, trimming can be applied after every full cycle over variables
at step \ref{step:trimfreq:sometimes} of Algorithm 2.
Finally, trimming can be applied after each sub-iteration
at step \ref{step:trimfreq:often} of the algorithm.

\begin{stexample}[Example 3]

Inspecting the histograms on Figure \ref{fig:example2}, it appears reasonable
to restrict the upper tail of the raked weights. A more detailed investigation
of the histogram reveals a somewhat greater concentration of the raked weights
around the value of 160,000, and sparse bars beyond 200,000. This latter number
will be used as the top cut-off point for trimming, and is provided as an input
to \stcmd{ipfraking} via option \stcmd{trimhiabs}. Also, I specified the absolute
lower bound of 2,000, which is the minimum of the original weights, but,
as the output in the previous example suggested, the calibrated weights tend to run
above 4,000, so specifying the lower limit as \stcmd{trimloabs(2000)} may not really
affect the calibration procedure.

\begin{stlog}
\input{ipfr.example3.trimabs.log.tex}\nullskip
\end{stlog}

The resulting coefficient of variation of weights, 0.857, is slightly
better than that with unrestricted range of weights, 0.872. The summary also shows
that the weights were capped at 200,000, as requested.

Setting the absolute limits on the range of the raked weights is often
very subjective. A somewhat better plan might be to set limits in terms
of the range of the adjustment factors, as shown in the next example. The relative
change in the weights can be bounded with \stcmd{trimlorel()} and \stcmd{trimhirel()}
options.
I also demonstrate here how to use the results of \stcmd{summarize} to feed
into \stcmd{ipfraking}. While ensuring that accurate numbers are being carried
over in the context of the code, the approach is fragile for interactive
work: simply running the single line with the sole
\stcmd{ipfraking} command that refers to the \stcmd{r()} return values
may break down if \stcmd{summarize} was not the
immediately preceding command.

\begin{stlog}
\input{ipfr.example3.trimsum.log.tex}\nullskip
\end{stlog}

\end{stexample}

Setting the trimming options too aggressively may lead to adverse
consequences. First, it may bias the estimates, as discussed in Section
\ref{subsec:pro:con}.
Second, as this example demonstrates, it can impede (statistical) convergence:
the output contains multiple warnings about targets not being achieved
within desired accuracy, while no problems were encountered without trimming.

\subsection{Tracking convergence}
\label{subsec:example:trace}

Let us now look in more detail into the issue of trimming frequency,
and demonstrate another diagnostic plot that can be produced by
\stcmd{ipfraking}.

\begin{stexample}[Example 4]

We return to the first set of options of Example 3, and
re-run the raking procedure.

\begin{stlog}
\input{ipfr.example4.sometimes.log.tex}\nullskip
\end{stlog}

The option \stcmd{trace} requests that trace plots be added to
the diagnostic plots, as shown on Figure \ref{fig:example4:sometimes}.
The trace plots are presented on the absolute scale and on the log scale.
The exponentially declining discrepancy appears to be a general phenomenon.
In other words, after the first few iterations,
discrepancy between the currently weighted totals to the control totals roughly follows
the rate of $\rm{const} \times \alpha^k$ for some $\alpha<1$, where $k$ is
the (outer cycle) iteration number. When convergence is very slow or the sample
size is very large, this rule may be helpful in determining the number
of iterations necessary to achieve the required accuracy, and hence
the expected computing time. Zero cross-cells and collinearity between
the control variables may make the convergence factor $\alpha$ close to 1 thus
hampering convergence. This happens when the control variables have
very similar meaning, such as age and grade of children: it is impossible
to have children of age 8 in grade 10.
Also, sets of interactions of categorical variables, such as interactions
of age group and education along with age group and race, are guaranteed to
produce zero cells in the cross-tabulation: it is impossible to have
any observations in the cells defined say by
(age under 40 interacted with higher education) on one margin against
(age above 60 interacted with white race) on the other.

\begin{figure}[!th]
\begin{center}
\epsfig{file=ipfraking_example4_sometimes}
\end{center}
\caption{Diagnostic plots for Example 4.}
\label{fig:example4:sometimes}
\end{figure}

While \stcmd{trimfreq(sometimes)} is the default in presence
of other trimming options, the behavior can be changed
with explicit specification of trimming frequency. Note that slightly
different weights will be produced that way.

\begin{stlog}
\input{ipfr.example4.often.log.tex}\nullskip
\end{stlog}

In this example, trimming the weights after adjusting each of the margins
led to fewer iterations. This may or may not translate to lower overall
computing times as more computing is performed within each iteration.

\end{stexample}

\subsection{Metadata}
\label{subsec:example:meta}

The results of raking operations can be stored with the newly created
weight variables for later review and reproduction of the results.
Let us reproduce the example in the previous section adding all the metadata
available:

\begin{stexample}[Example 5]

\begin{stlog}
\input{ipfr.example5.log.tex}\nullskip
\end{stlog}

\end{stexample}

The following characteristics are stored with the newly created weight variable
(see \pref{char}).

\begin{tabular}{ll}
    \stcmd{command} & The full command as typed by the user \\
    {\it matrix name} & The relative matrix difference from the corresponding \\
                    & control total, see \dref{functions} \\
    \stcmd{trimhiabs}, \stcmd{trimloabs}, & Corresponding trimming options,
                    if specified \\
    \stcmd{trimhirel}, \stcmd{trimlorel}, & \\
    \stcmd{trimfrequency} & \\
    \stcmd{maxctrl} & the greatest \stcmd{mreldif} between the targets \\
                    & and the achieved weighted totals \\
    \stcmd{objfcn}  & the value of the relative weight change $D_k$ (\ref{eq:conv:ratio:weights})
                    at exit \\
    \stcmd{converged} & whether \stcmd{ipfraking} exited due to convergence (1) \\
                    & vs. due to an increase in the objective function \\
                    & or reaching the limit on the number of iterations (0)
\end{tabular}

Also, \stcmd{ipfraking} stores the notes regarding the control matrices
used, and which of the margins did not match the control totals, if any.
See \dref{notes}.

\subsection{Replicate weights}

As discussed in Section \ref{subsec:variance}, one of the greater challenges
of weight calibration is ensuring that variance estimates take into account
the greater precision achieved by adjusting the sample towards the fixed
population quantities. As estimating the variances using linearization
is cumbersome, replicate variance estimation may be more attractive.

\begin{stexample}[Example 6]

The simplest code for calibrated replicate weights is obtained by calling
\stcmd{ipfraking} from within \stcmd{bsweights} \citep{kolenikov:2010}
which can pass the name of a replicate weight variable to an arbitrary
calibration routine. In this example, we shall use the same settings
as in Section \ref{subsec:acs} and thus we shall have the calibrated weight
\stcmd{rakedwgt2} which was produced in that example as the main weight
for which the bootstrap weights provide the measure of sampling variability.

\begin{stlog}
\input{ipfr.example6.bsw.log.tex}\nullskip
\end{stlog}

The options of \stcmd{bsweights} request 310 replicate weights
(a multiple of 31 strata), resample one less PSU than available in
a given stratum, and obtain the first-order balance within a stratum.
With the 2 PSU/stratum design and these options, \stcmd{bsweights}
produces random half-samples of data. The at-character \stcmd{@} is a placeholder
for the name of the replicate weight variable.
For explanations of these and other options of \stcmd{bsweights},
see \citet{kolenikov:2010}. The procedure took about 3 minutes
on a laptop computer, which can be considered moderately
computationally intensive beyond interactive.
A new option of \stcmd{ipfraking} in the above code is
\stcmd{nograph} that suppresses the histograms.
The additional asserts \citep{gould:2003:tip3} following the bootstrap
weight generation demonstrate how the minimal quality assurance
can be done on the bootstrap weights in the weight production workflow.


A more compact set of weights can be developed based on the existing
BRR weights and a slightly more explicit code cycling over the weight
variables:

\begin{stlog}
\input{ipfr.example6.brr.log.tex}\nullskip
\end{stlog}

The data can be analyzed with the standard \stcmd{svy} prefix,
and the standard errors will appropriately capture the efficiency
gains from weight calibration. No additional action is required
for the analyst or researcher.

\end{stexample}

{\bf CAUTION:} the input weights for the replicate weight calibration
must be the probability replicate weights. The existing NHANES II weights
have been adjusted for non-response and calibrated by the data provider,
and are used above for demonstration purposes only.

\section{Error messages and troubleshooting}
\label{subsec:tbshooting}

\subsection{Critical errors}

The following critical errors will stop execution of
\stcmd{ipfraking}.

\noindent
{\tt pweight is required}

\morehang
    The \stcmd{[pweight=\ldots]} component of \stcmd{ipfraking}
    syntax is required. Probability weights must be specified as
    inputs to \stcmd{ipfraking}.

\noindent
    {\tt ctotal() is required}

    \morehang
    The \stcmd{ctotal()} component of \stcmd{ipfraking}
    syntax is required. Names of the matrices containing the
    control totals must be specified.

    \noindent
    {\tt one and only one of generate() or replace must be specified}

    \morehang
    Either \stcmd{generate()} option with the name of the new variable
    must be supplied to \stcmd{ipfraking}, or \stcmd{replace} to replace
    the variable specified in \stcmd{[pw=\ldots]} statement.

    \noindent
    {\tt raking procedure appears diverging}

    \morehang
    The maximum relative difference of weights $D_k$ has increased from
    the previous
    iteration. This may or may not indicate a problem. Re-run \stcmd{ipfraking}
    with \stcmd{nodivergence} option to override the warning.

    \noindent
    {\tt cannot process matrix {\it matrix{\_}name}}

    \morehang
    For whatever reason, \stcmd{ipfraking} could not process this matrix.
    The matrix may not have been defined or the variables in this matrix
    cannot be found.

    \noindent
    {\tt variable {\it varname} corresponding to the control matrix
    {\it matrix{\_}name} \\ not found}

    \morehang
    The variables contained in row or column names of this matrix
    cannot be found.

    \noindent
    {\tt {\it varname1} and {\it varname2} variables are not compatible}

    \morehang
    When running \stcmd{total} {\it varname1}\stcmd{, over(}{\it varname2}\stcmd{)},
    an error was encountered. One of the variables may be a string variable
    or have missing values resulting in an empty estimation sample.

    \noindent
    {\tt categories of {\it varname} do not match in the control {\it matrix{\_}name} \\
    and in the data (nolab option)}

    \morehang
    There was a mismatch in the categories of {\it varname} found in the data
    and in the control matrix {\it matrix{\_}name}. This could happen for any of the
    following reasons: (i) there were more categories in one than in the other;
    (ii) the entries are in the wrong order in the control matrix; (iii) the labels
    in the control matrix do not correspond to the category values in the data set;
    (iv) the control matrix was obtained via \stcmd{total}
    {\it varname2}\stcmd{, over(}{\it varname}\stcmd{)}, but \stcmd{nolabel} suboption
    of \stcmd{over()} was omitted, and the labels of the control matrix may include
    some unexpected text. Tabulate {\it varname} without labels, and compare the results
    to the matrix listing of the {\it matrix{\_}name}.

    \noindent
    {\tt cannot compute controls for {\it matrix{\_}name} over
    {\it varname} with the current \\ weights}

    \morehang
    This is a generic error message that something bad happened while
    \stcmd{ipfraking} was computing the totals for the current set of weights.
    This error message should generally be very rare, but as computing
    the totals may be the slowest operation of the iterative optimization
    process, stopping \stcmd{ipfraking} with a {\it Ctrl+Break} combination or
    the {\it Break} GUI button may produce this error message.

    \noindent
    {\tt trimhiabs|trimloabs|trimhirel|trimlorel must be a positive number}

    \morehang
    One or more of the trimming options are given as a non-positive number
    or a non-number.

    \noindent
    {\tt trimhiabs must be greater than trimloabs}

    \noindent
    {\tt trimhirel must be greater than trimlorel}

    \morehang
    The trimming parameters are illogical (the lower bound is greater than the upper bound).
    Respecify the values of the trimming parameters.

\bigskip

\subsection{Other errors and warnings}

The following warning messages may be produced by
\stcmd{ipfraking}. The program will continue running, but you must
double-check the results for potential problems.

\noindent
    {\tt the totals of the control matrices are different}

    \morehang
    The sum of values of the control matrices are different.
    These sums will be listed for review. Convergence is still
    possible, but some of the control total checks are likely to fail.

    \noindent
    {\tt trimfrequency() option is specified without numeric settings; will be \\ ignored}

    \morehang
    The option \stcmd{trimfrequency()} was specified without any numeric trimming options.
    There is no way to interpret this, and \stcmd{ipfraking} will proceed without
    trimming.

    \noindent
    {\tt trimfrequency() option is specified incorrectly, assume default value \\ (sometimes)}

    \morehang
    Something other than \stcmd{often}, \stcmd{sometimes} or \stcmd{once} was supplied
    in \stcmd{trimfrequency}, and the default value is being used instead.

    \noindent
    {\tt raking procedure did not converge}

    \morehang
    The maximum number of iterations was reached, but weights never met the convergence
    criteria (see step \ref{step:check:weight:conv} of Algorithm 2 in Section \ref{subsec:trimming}).
    The user may want to increase the number of iterations or relax convergence criteria.

    \noindent
    {\tt the controls {\it matrix{\_}name} did not match}

    \morehang
    After convergence of weights was declared, \stcmd{ipfraking}
    checked again the control totals, and found that the results
    differed from the target for one or more of the control total
    matrices. Any of the following can cause this: (i) the sum of
    entries of this particular matrix differs from the others;
    (ii) the trimming options are too restrictive, and do not allow
    the weights to adjust enough; (iii) the problem may not have a
    solution due to incompatible control totals or a bad sample.

    \noindent
    {\tt division by zero weighted total encountered with
    {\it matrix{\_}name} control}

    \morehang
    The weights for a category of the control variable summed
    to zero. \stcmd{ipfraking} will skip calibration over this
    variable and proceed to the next one.

    \noindent
    {\tt \# missing values of {\it varname} encountered; convergence will be impaired}

    \morehang
    A control variable has missing values in the calibration sample.
    There is little way for \stcmd{ipfraking} to figure out how to deal
    with the weights for the observations with missing values. The user would need
    either to restrict the sample to non-missing values of all control variables,
    to impute the missing values or to create a separate category for the missing
    values of a given control variable (which may lead to difficulties in defining
    valid population control totals for it).

\section*{Acknowledgements}

The author is grateful to Ben Phillips, Andrew Burkey and Brady West,
as well as the editor and an anonymous referee,
who suggested additional functionality and provided helpful comments
to improve the readability of this article. The opinions stated in this paper
are of the author only, and do not represent the position of Abt SRBI.

\bibliographystyle{sj}
% \bibliography{everything}
\bibliography{ipfraking}

\appendix

\section*{Appendix: Common notation}

\begin{tabular}{llp{9.5cm}}
    $\mathcal{C}_k$ & Sec. \ref{subsec:calibration} & Calibration cell \\
    $D_k$ & (\ref{eq:conv:ratio:weights}) & Maximum relative difference of weights
            from iteration $k-1$ to iteration $k$ \\
    $\delta_D$ & Sec. \ref{subsec:trimming} & Convergence criteria for $D_k$ \\
    $\delta_T$ & Sec. \ref{subsec:trimming} & Quality control criteria for control totals \\
    $i$ & Sec. \ref{subsec:totals} & Subscript $i$ usually applies to units in population \\
    $j$ & Sec. \ref{subsec:totals} & Subscript $j$ usually applies to units in sample \\
    $k$ & Sec. \ref{subsec:trimming} & The outer cycle iteration number \\
    $K$ & Sec. \ref{subsec:trimming} & The maximum number of the outer cycle iterations \\
    $l$ & Sec. \ref{subsec:trimming} & Relative limit on weights: all the weights will be made
        $\ge (l \times$ the input weight) \\
    $l$ & & summation index, where I run out of other traditional integer letters \\
    $L$ & Sec. \ref{subsec:trimming} & Absolute limit on weights: all the weights will be made
        $\ge L$ \\
    $n$ & & Sample size; number of sampled units \\
    $N$ & & Population size; number of units in population or frame \\
    $\pi_i$ & & Probability of selection of unit $i$
            specified by the sampling design \\
%
    $\mathcal{S}$ & Sec. \ref{subsec:totals} & Sample; set of sampled units \\
    $T[y]$ & (\ref{eq:total:pop}) & Population-based total of variable $[y]$ \\
    $t_m[y]$ & (\ref{eq:total:sample}) & Sample-based weighted estimate of the total
        $T[y]$; subscript $m=1,2,3$ indicates the type of weights used in computing
        the total \\
    $u$ & Sec. \ref{subsec:trimming} & Relative upper limit on weights: all the weights will be made
        $\le (u \times$ the input weight) \\
    $L$ & Sec. \ref{subsec:trimming} & Absolute upper limit on weights: all the weights will be made
        $\le U$ \\
    $\mathcal{U}$ & Sec. \ref{subsec:totals} & Universe or population; set of units in population \\
%
    $w_{1i}$ & (\ref{eq:prob:weight}) & Probability (design) weights;
        inverse probability of selection \\
    $w_{2j}$ & (\ref{eq:ps:weight}) & Post-stratified weights;
        random; depend on group sizes in sample; analytically computable \\
    $w_{3j}$ & Sec. \ref{subsec:calibration} & Calibrated (raked) weights; random;
        require iterative optimization \\
%
    $x_v$ & Sec. \ref{subsec:raking:algorithm} & the $v$-th calibration (control)
        variable, $v=1,\ldots,p$. The population total $T[x_v]$ is known. \\
\end{tabular}

\begin{aboutauthor}
  Stanislav (Stas) Kolenikov is a Senior Survey Statistician at Abt SRBI.
  His research interests include
  applications of statistical methods in public opinion research,
  such as advanced sampling techniques, survey weighting,
  calibration, missing data imputation, and variance estimation.
  Besides survey statistics, Stas has extensive experience developing and applying
  statistical methods in social sciences, with focus on structural equation
  modeling and microeconometrics. He has been writing Stata programs since
  1998 when Stata was version 5.
\end{aboutauthor}
